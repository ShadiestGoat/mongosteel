"use strict";var __awaiter=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))((function(i,r){function c(e){try{s(o.next(e))}catch(e){r(e)}}function d(e){try{s(o.throw(e))}catch(e){r(e)}}function s(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(c,d)}s((o=o.apply(e,t||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.model=exports.waitForConnection=void 0;const connection_1=require("./connection"),schema_1=require("./schema");function waitForConnection(){const e=Date.now()+3e4;for(;!connection_1.mongoSteelConnection.on;)if(Date.now()>e)throw new Error("There is no connection!")}function getCollection(e){if(!connection_1.mongoSteelConnection.on)throw new Error("Please don't manually set this variable!");return connection_1.mongoSteelConnection.db.collection(e)}exports.waitForConnection=waitForConnection;class trueModel{constructor(e,t,n,o){this.colName=e;const i=t.validate(n);if(!i.valid&&!connection_1.mongoSteelConnection.opts.noVerification)throw new schema_1.MongoSteelValidityError(i);this.doc=i.valid?i.res:n,this.schema=t,this.saved=!1,this.oldId="",this.methods=o}save(){return __awaiter(this,void 0,void 0,(function*(){const e=getCollection(this.colName);!connection_1.mongoSteelConnection.opts.noIdDetection&&this.saved&&this.oldId==this.doc._id&&(console.warn(`The _id ${this.doc._id} has already been saved once, overriding it with a new id...\nTo avoid this, use mongoSteel option { noIdDetection:true }`),delete this.doc._id);const t=yield e.insertOne(this.doc);if(!t.insertedId)throw Error("Not inserted");if(!connection_1.mongoSteelConnection.opts.noDocsUpdate){const n=yield e.findOne({_id:t.insertedId});if(!n)throw Error("Weird");this.doc=n}return this.saved=!0,this.oldId=t.insertedId,this.doc}))}static find(e){return __awaiter(this,void 0,void 0,(function*(){const t=getCollection(this.colName);return yield t.find(e).toArray()}))}static findOne(e){return __awaiter(this,void 0,void 0,(function*(){const t=getCollection(this.colName);return yield t.findOne(e)}))}static findOneAndDelete(e){return __awaiter(this,void 0,void 0,(function*(){const t=getCollection(this.colName),n=yield t.findOneAndDelete(e);if(!n.ok)throw new Error("findOneAndDelete returned not OK");return n.value}))}static findOneAndReplace(e,t){return __awaiter(this,void 0,void 0,(function*(){const n=this.schema.validate(t);if(!n.valid)throw new schema_1.MongoSteelValidityError(n);t=n.res;const o=getCollection(this.colName),i=yield o.findOneAndReplace(e,t);if(!i.ok)throw new Error("findOneAndReplace returned not OK");return i.value}))}static findOneAndUpdate(e,t){return __awaiter(this,void 0,void 0,(function*(){const n=this.schema.validate(t,{ignoreDefault:!0,ignoreRequired:!0});if(!n.valid)throw new schema_1.MongoSteelValidityError(n);const o=getCollection(this.colName),i=yield o.findOneAndUpdate(e,{$set:t});if(!i.ok)throw new Error("findOneAndUpdate returned not OK");return i.value}))}static deleteMany(e){return __awaiter(this,void 0,void 0,(function*(){const t=getCollection(this.colName);yield t.deleteMany(e)}))}}function model(e,t,n){class o extends trueModel{constructor(o={}){super(e,t,o,n)}}return o.colName=e,o.schema=t,o.methods=n,o}exports.model=model;