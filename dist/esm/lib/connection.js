var __awaiter=this&&this.__awaiter||function(o,n,e,t){return new(e||(e=Promise))((function(i,r){function c(o){try{l(t.next(o))}catch(o){r(o)}}function s(o){try{l(t.throw(o))}catch(o){r(o)}}function l(o){var n;o.done?i(o.value):(n=o.value,n instanceof e?n:new e((function(o){o(n)}))).then(c,s)}l((t=t.apply(o,n||[])).next())}))};import{MongoClient}from"mongodb";export function toUrl(o){return["dbName","location","password","user"].forEach((n=>{if(!Object.keys(o).includes(n))throw Error(`${n} is required in the options!`)})),o.dbOpts||(o.dbOpts={}),`mongodb://${encodeURI(o.user)}:${encodeURI(o.password)}@${encodeURI(o.location)}/${o.dbName}${0==Object.keys(o.dbOpts).length?"":"?"}${Object.keys(o.dbOpts).map(((n,e)=>{var t;return`${0==e?"":"&"}${encodeURI(`${n}=${(null!==(t=o.dbOpts)&&void 0!==t?t:{})[n]}`)}`})).join("")}`}export let mongoSteelConnection={on:!1,models:{},opts:{}};export class MongoSteel{static connect(o,n,e){return __awaiter(this,void 0,void 0,(function*(){if(mongoSteelConnection.on){if(o)throw new Error(`I already have a connection to ${mongoSteelConnection.url}!`);return mongoSteelConnection.db}if(!o)throw new Error("I have nothing to connect to!");const t="string"==typeof o?encodeURI(o):toUrl(o),i=yield MongoClient.connect(t,Object.assign({useNewUrlParser:!0,useUnifiedTopology:!0},n)),r=i.db(),c=Object.assign({},e);return mongoSteelConnection={on:!0,db:r,client:i,url:t,opts:c,models:mongoSteelConnection.models},r}))}static disconnect(){var o;return __awaiter(this,void 0,void 0,(function*(){mongoSteelConnection&&(yield null===(o=mongoSteelConnection.client)||void 0===o?void 0:o.close(),mongoSteelConnection={on:!1,client:void 0,db:void 0,url:void 0,models:mongoSteelConnection.models,opts:mongoSteelConnection.opts})}))}}