var S=Object.create;var f=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,L=Object.prototype.hasOwnProperty;var h=t=>f(t,"__esModule",{value:!0});var F=typeof require!="undefined"?require:t=>{throw new Error('Dynamic require of "'+t+'" is not supported')};var x=(t,e)=>{h(t);for(var n in e)f(t,n,{get:e[n],enumerable:!0})},R=(t,e,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of T(e))!L.call(t,r)&&r!=="default"&&f(t,r,{get:()=>e[r],enumerable:!(n=k(e,r))||n.enumerable});return t},A=t=>R(h(f(t!=null?S(v(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);x(exports,{MongoSteel:()=>w,Schema:()=>y,model:()=>M,toUrl:()=>g});var u=class extends Error{constructor(e){super("This document is not valid!");Object.setPrototypeOf(this,u.prototype),this.obj=e}},y=class{constructor(e){function n(i){if(typeof i=="string")return i||="string",{type:i,required:!0};if(Array.isArray(i))return i.length==2?{type:["string",n(i[1])],required:!0}:{type:[n(i[0])],required:!0};if(typeof i!="object")throw new Error("Unrecognised schema type!");return Object.keys(i).includes("type")&&Object.keys(i).includes("required")?(typeof i.type=="object"&&(i.type=n(i.type)),i):r(i)}function r(i){let d={};if(Array.isArray(i))throw new Error("Schema can't be an array!");if(typeof i!="object")throw new Error("Unrecognised schema type!");return Object.keys(i).forEach(a=>{d[a]=n(i[a])}),d}this.schema=r(e)}validate(e,n={}){if(typeof e!="object"||Array.isArray(e))return{valid:!1,reason:"majorBadType"};function r(a,s,o){switch(a.type){case"boolean":return typeof s!="boolean"?{valid:!1,reason:"badType",badKey:o}:!1;case"number":return typeof s!="number"?{valid:!1,reason:"badType",badKey:o}:!1;case"string":return typeof s!="string"?{valid:!1,reason:"badType",badKey:o}:a.pattern&&!a.pattern?.test(s)?{valid:!1,reason:"badType",badKey:o}:!1;case"mixed":return!1;default:return!1}}let i="";function d(a,s){if(Object.keys(a).includes("type")&&Object.keys(a).includes("required")){if(!(typeof s=="undefined"&&!a.required)){let o=r(a,s,i);if(o)return o}}else for(let o in a)if(typeof s=="object"&&!Array.isArray(s)&&!Object.keys(s).includes(o)){if(a[o].required&&!n.ignoreRequired)return{valid:!1,reason:"required",badKey:o};a[o].default&&!n.ignoreDefault&&(typeof a[o].default=="function"?e[o]=a[o].default():e[o]=a[o].default)}else if(Array.isArray(a[o].type)){if(a[o].type.length==2){if(Array.isArray(s[o]))return{valid:!1,reason:"badType",badKey:o};for(let c in s[o]){let p=d(a[o].type[1],s[o][c]);if(!p.valid)return p}}if(!Array.isArray(s[o]))return{valid:!1,reason:"badType",badKey:o};i=o,s[o].forEach(c=>{let p=d(a[o].type[0],c);if(!p.valid)return p})}else if(typeof a[o].type=="object"){let c=d(a[o].type,s[o]);if(!c.valid)return c}else{if(typeof s[o]=="undefined"&&!a[o].required)continue;let c=r(a[o],s[o],o);if(c)return c}return{valid:!0,res:e}}return d(this.schema,e)}};var m=A(require("mongodb"));function g(t){return["dbName","location","password","user"].forEach(e=>{if(!Object.keys(t).includes(e))throw Error(`${e} is required in the options!`)}),t.dbOpts||={},encodeURI(`mongodb${/\d\d\d\.\d\d\d\.\d\d\.\d\d\d/.test(t.location)?"":"+srv"}://${t.user}:${t.password}@${t.location}/${t.dbName}${Object.keys(t.dbOpts).length==0?"":"?"}${Object.keys(t.dbOpts).map((e,n)=>`${n==0?"":"&"}${`${e}=${t.dbOpts[e]}`}`).join("")}`)}var l={on:!1,models:{},opts:{}},w=class{static async connect(e,n,r){if(l.on){if(e)throw new Error(`I already have a connection to ${l.url}!`);return l.db}if(!e)throw new Error("I have nothing to connect to!");let i=typeof e=="string"?encodeURI(e):g(e),d=await m.MongoClient.connect(i,Object.assign({useNewUrlParser:!0,useUnifiedTopology:!0},n)),a=d.db(),s=Object.assign({},r);return l={on:!0,db:a,client:d,url:i,opts:s,models:l.models},a}static async disconnect(){l&&(await l.client?.close(),l={on:!1,client:void 0,db:void 0,url:void 0,models:l.models,opts:l.opts})}};function O(t){let e=n=>{l.on?n(l.db.collection(t)):setTimeout(()=>e(n),100)};return new Promise(e)}var b=class{constructor(e,n,r,i){let d=n.validate(r);if(!d.valid&&!l.opts.noVerification)throw new u(d);this.doc=d.valid?d.res:r,this.schema=n,this.saved=!1,this.oldId="",this.methods=i,this.collection=O(e)}async save(){if(!l.opts.noIdDetection&&this.saved&&this.oldId==this.doc._id){let{_id:n,...r}=this.doc;this.doc=r,console.warn(`The _id ${n} has already been saved once, overriding it with a new id!`)}let e=await(await this.collection).insertOne(this.doc);if(!e.insertedId)throw Error("Not inserted");if(!l.opts.noDocsUpdate){let n=await(await this.collection).findOne({_id:e.insertedId});if(!n)throw Error("Weird");this.doc=n}return this.saved=!0,this.oldId=e.insertedId,this.doc}static async find(e){return await(await this.collection).find(e).toArray()}static async findOne(e){return await(await this.collection).findOne(e)}static async findOneAndDelete(e){let n=await(await this.collection).findOneAndDelete(e);if(!n.ok)throw new Error("findOneAndDelete returned not OK");return n.value}static async findOneAndReplace(e,n){let r=this.schema.validate(n);if(!r.valid)throw new u(r);n=r.res;let i=await(await this.collection).findOneAndReplace(e,n);if(!i.ok)throw new Error("findOneAndReplace returned not OK");return i.value}static async findOneAndUpdate(e,n){let r=this.schema.validate(n,{ignoreDefault:!0,ignoreRequired:!0});if(!r.valid)throw new u(r);let i=await(await this.collection).findOneAndUpdate(e,{$set:n});if(!i.ok)throw new Error("findOneAndUpdate returned not OK");return i.value}static async deleteMany(e){await(await this.collection).deleteMany(e)}};function M(t,e,n){class r extends b{constructor(d={}){super(t,e,d,n)}}return r.collection=O(t),r.schema=e,r.methods=n,r}0&&(module.exports={MongoSteel,Schema,model,toUrl});
