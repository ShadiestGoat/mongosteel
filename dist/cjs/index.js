var M=Object.create;var f=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var m=o=>f(o,"__esModule",{value:!0});var I=typeof require!="undefined"?require:o=>{throw new Error('Dynamic require of "'+o+'" is not supported')};var L=(o,e)=>{m(o);for(var i in e)f(o,i,{get:e[i],enumerable:!0})},R=(o,e,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of k(e))!v.call(o,a)&&a!=="default"&&f(o,a,{get:()=>e[a],enumerable:!(i=S(e,a))||i.enumerable});return o},x=o=>R(m(f(o!=null?M(T(o)):{},"default",o&&o.__esModule&&"default"in o?{get:()=>o.default,enumerable:!0}:{value:o,enumerable:!0})),o);L(exports,{MongoSteel:()=>g,Schema:()=>h,model:()=>O,toUrl:()=>y});var u=class extends Error{constructor(e){super("This document is not valid!");Object.setPrototypeOf(this,u.prototype),this.obj=e}},h=class{constructor(e){function i(n){if(typeof n=="string")return n||(n="string"),{type:n,required:!0};if(Array.isArray(n))return n.length==2?{type:["string",i(n[1])],required:!0}:{type:[i(n[0])],required:!0};if(typeof n!="object")throw new Error("Unrecognised schema type!");return Object.keys(n).includes("type")&&Object.keys(n).includes("required")?(typeof n.type=="object"&&(n.type=i(n.type)),n):a(n)}function a(n){let l={};if(Array.isArray(n))throw new Error("Schema can't be an array!");if(typeof n!="object")throw new Error("Unrecognised schema type!");return Object.keys(n).forEach(r=>{l[r]=i(n[r])}),l}this.schema=a(e)}validate(e,i={}){if(typeof e!="object"||Array.isArray(e))return{valid:!1,reason:"majorBadType"};function a(r,s,t){switch(r.type){case"boolean":return typeof s!="boolean"?{valid:!1,reason:"badType",badKey:t}:!1;case"number":return typeof s!="number"?{valid:!1,reason:"badType",badKey:t}:!1;case"string":return typeof s!="string"?{valid:!1,reason:"badType",badKey:t}:r.pattern&&!r.pattern?.test(s)?{valid:!1,reason:"badType",badKey:t}:!1;case"mixed":return!1;default:return console.warn(`Unknown type for ${t}! The schema says ${r.type}`),!1}}let n="";function l(r,s){if(Object.keys(r).includes("type")&&Object.keys(r).includes("required")){let t=a(r,s,n);if(t)return t}else for(let t in r)if(typeof s=="object"&&!Array.isArray(s)&&!Object.keys(s).includes(t)){if(r[t].required&&!i.ignoreRequired)return{valid:!1,reason:"required",badKey:t};r[t].default&&!i.ignoreDefault&&(typeof r[t].default=="function"?e[t]=r[t].default():e[t]=r[t].default);continue}else if(Array.isArray(r[t].type)){if(r[t].type.length==2){if(typeof s[t]!="object"||Array.isArray(s[t]))return{valid:!1,reason:"badType",badKey:t};for(let c in s[t]){let p=l(r[t].type[1],s[t][c]);if(!p.valid)return p}}if(!Array.isArray(s[t]))return{valid:!1,reason:"badType",badKey:t};n=t,s[t].forEach(c=>{let p=l(r[t].type[0],c);if(!p.valid)return p})}else if(typeof r[t].type=="object"){let c=l(r[t].type,s[t]);if(!c.valid)return c}else{let c=a(r[t],s[t],t);if(c)return c}return{valid:!0,res:e}}return l(this.schema,e)}};var w=x(require("mongodb"));function y(o){return["dbName","location","password","user"].forEach(e=>{if(!Object.keys(o).includes(e))throw Error(`${e} is required in the options!`)}),o.dbOpts||(o.dbOpts={}),`mongodb://${encodeURI(o.user)}:${encodeURI(o.password)}@${encodeURI(o.location)}/${o.dbName}${Object.keys(o.dbOpts).length==0?"":"?"}${Object.keys(o.dbOpts).map((e,i)=>`${i==0?"":"&"}${encodeURI(`${e}=${(o.dbOpts??{})[e]}`)}`).join("")}`}var d={on:!1,models:{},opts:{}},g=class{static async connect(e,i,a){if(d.on){if(e)throw new Error(`I already have a connection to ${d.url}!`);return d.db}if(!e)throw new Error("I have nothing to connect to!");let n=typeof e=="string"?encodeURI(e):y(e),l=await w.MongoClient.connect(n,Object.assign({useNewUrlParser:!0,useUnifiedTopology:!0},i)),r=l.db(),s=Object.assign({},a);return d={on:!0,db:r,client:l,url:n,opts:s,models:d.models},r}static async disconnect(){d&&(await d.client?.close(),d={on:!1,client:void 0,db:void 0,url:void 0,models:d.models,opts:d.opts})}};var b=class{constructor(e,i,a,n){let l=i.validate(a);if(!l.valid&&!d.opts.noVerification)throw new u(l);this.doc=l.valid?l.res:a,this.schema=i,this.saved=!1,this.oldId="",this.methods=n;let r=setInterval(function(){d.on&&(clearInterval(r),this.collection=d.db.collection(e))},100)}async save(){!d.opts.noIdDetection&&this.saved&&this.oldId==this.doc._id&&(console.warn(`The _id ${this.doc._id} has already been saved once, overriding it with a new id...
To avoid this, use mongoSteel option { noIdDetection:true }`),delete this.doc._id);let e=await this.collection.insertOne(this.doc);if(!e.insertedId)throw Error("Not inserted");if(!d.opts.noDocsUpdate){let i=await this.collection.findOne({_id:e.insertedId});if(!i)throw Error("Weird");this.doc=i}return this.saved=!0,this.oldId=e.insertedId,this.doc}static async find(e){return await this.collection.find(e).toArray()}static async findOne(e){return await this.collection.findOne(e)}static async findOneAndDelete(e){let i=await this.collection.findOneAndDelete(e);if(!i.ok)throw new Error("findOneAndDelete returned not OK");return i.value}static async findOneAndReplace(e,i){let a=this.schema.validate(i);if(!a.valid)throw new u(a);i=a.res;let n=await this.collection.findOneAndReplace(e,i);if(!n.ok)throw new Error("findOneAndReplace returned not OK");return n.value}static async findOneAndUpdate(e,i){let a=this.schema.validate(i,{ignoreDefault:!0,ignoreRequired:!0});if(!a.valid)throw new u(a);let n=await this.collection.findOneAndUpdate(e,{$set:i});if(!n.ok)throw new Error("findOneAndUpdate returned not OK");return n.value}static async deleteMany(e){await this.collection.deleteMany(e)}};function O(o,e,i){class a extends b{constructor(r={}){super(o,e,r,i)}}let n=setInterval(function(){d.on&&(clearInterval(n),a.collection=d.db.collection(o))},100);return a.schema=e,a.methods=i,a}0&&(module.exports={MongoSteel,Schema,model,toUrl});
